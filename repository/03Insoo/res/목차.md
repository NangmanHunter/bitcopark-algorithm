CLRS  
ㄴI Foundations   
　ㄴIntroduction 3   
　ㄴ1 The Role of Algorithms in Computing 5   
　　ㄴ1.1 Algorithms 5   
　　ㄴ1.2 Algorithms as a technology 12   
　ㄴ2 Getting Started 17   
　　ㄴ2.1 Insertion sort 17   
　　ㄴ2.2 Analyzing algorithms 25   
　　ㄴ2.3 Designing algorithms 34   
　ㄴ3 Characterizing Running Times 49   
　　ㄴ3.1 O-notation, �-notation, and ‚-notation 50   
　　ㄴ3.2 Asymptotic notation: formal deûnitions 53   
　　ㄴ3.3 Standard notations and common functions 63   
　ㄴ4 Divide-and-Conquer 76   
　　ㄴ4.1 Multiplying square matrices 80   
　　ㄴ4.2 Strassen’s algorithm for matrix multiplication 85   
　　ㄴ4.3 The substitution method for solving recurrences 90   
　　ㄴ4.4 The recursion-tree method for solving recurrences 95   
　　ㄴ4.5 The master method for solving recurrences 101 ?   
　　ㄴ4.6 Proof of the continuous master theorem 107 ?   
　　ㄴ4.7 Akra-Bazzi recurrences 115   
　ㄴ5 Probabilistic Analysis and Randomized Algorithms 126   
　　ㄴ5.1 The hiring problem 126   
　　ㄴ5.2 Indicator random variables 130   
　　ㄴ5.3 Randomized algorithms 134 ?   
　　ㄴ5.4 Probabilistic analysis and further uses of indicator random   variables 140   
ㄴII Sorting and Order Statistics   
　ㄴIntroduction 157  
　ㄴ6 Heapsort 161   
　　ㄴ6.1 Heaps 161   
　　ㄴ6.2 Maintaining the heap property 164   
　　ㄴ6.3 Building a heap 167   
　　ㄴ6.4 The heapsort algorithm 170   
　　ㄴ6.5 Priority queues 172   
　ㄴ7 Quicksort 182   
　　ㄴ7.1 Description of quicksort 183   
　　ㄴ7.2 Performance of quicksort 187   
　　ㄴ7.3 A randomized version of quicksort 191   
　　ㄴ7.4 Analysis of quicksort 193   
　ㄴ8 Sorting in Linear Time 205   
　　ㄴ8.1 Lower bounds for sorting 205   
　　ㄴ8.2 Counting sort 208   
　　ㄴ8.3 Radix sort 211   
　　ㄴ8.4 Bucket sort 215   
　ㄴ9 Medians and Order Statistics 227   
　　ㄴ9.1 Minimum and maximum 228   
　　ㄴ9.2 Selection in expected linear time 230   
　　ㄴ9.3 Selection in worst-case linear time 236   
ㄴIII Data Structures   
　ㄴIntroduction 249   
　ㄴ10 Elementary Data Structures 252   
　　ㄴ10.1 Simple array-based data structures: arrays, matrices, stacks,   queues 252   
　　ㄴ10.2 Linked lists 258   
　　ㄴ10.3 Representing rooted trees 265   
　ㄴ11 Hash Tables 272   
　　ㄴ11.1 Direct-address tables 273   
　　ㄴ11.2 Hash tables 275   
　　ㄴ11.3 Hash functions 282   
　　ㄴ11.4 Open addressing 293   
　　ㄴ11.5 Practical considerations 301   
　ㄴ12 Binary Search Trees 312   
　　ㄴ12.1 What is a binary search tree? 312   
　　ㄴ12.2 Querying a binary search tree 316   
　　ㄴ12.3 Insertion and deletion 321   
　ㄴ13 Red-Black Trees 331   
　　ㄴ13.1 Properties of red-black trees 331   
　　ㄴ13.2 Rotations 335   
　　ㄴ13.3 Insertion 338   
　　ㄴ13.4 Deletion 346   
ㄴIV Advanced Design and Analysis Techniques   
　ㄴIntroduction 361   
　ㄴ14 Dynamic Programming 362   
　　ㄴ14.1 Rod cutting 363   
　　ㄴ14.2 Matrix-chain multiplication 373   
　　ㄴ14.3 Elements of dynamic programming 382   
　　ㄴ14.4 Longest common subsequence 393   
　　ㄴ14.5 Optimal binary search trees 400   
　ㄴ15 Greedy Algorithms 417   
　　ㄴ15.1 An activity-selection problem 418   
　　ㄴ15.2 Elements of the greedy strategy 426   
　　ㄴ15.3 Huffman codes 431   
　　ㄴ15.4 Ofüine caching 440   
　ㄴ16 Amortized Analysis 448   
　　ㄴ16.1 Aggregate analysis 449   
　　ㄴ16.2 The accounting method 453   
　　ㄴ16.3 The potential method 456   
　　ㄴ16.4 Dynamic tables 460   
ㄴV Advanced Data Structures   
　ㄴIntroduction 477   
　ㄴ17 Augmenting Data Structures 480   
　　ㄴ17.1 Dynamic order statistics 480   
　　ㄴ17.2 How to augment a data structure 486   
　　ㄴ17.3 Interval trees 489   
　ㄴ18 B-Trees 497   
　　ㄴ18.1 Deûnition of B-trees 501   
　　ㄴ18.2 Basic operations on B-trees 504   
　　ㄴ18.3 Deleting a key from a B-tree 513   
　ㄴ19 Data Structures for Disjoint Sets 520   
　　ㄴ19.1 Disjoint-set operations 520   
　　ㄴ19.2 Linked-list representation of disjoint sets 523   
　　ㄴ19.3 Disjoint-set forests 527 ?   
　　ㄴ19.4 Analysis of union by rank with path compression 531   
ㄴVI Graph Algorithms   
　ㄴIntroduction 547   
　ㄴ20 Elementary Graph Algorithms 549   
　　ㄴ20.1 Representations of graphs 549   
　　ㄴ20.2 Breadth-ûrst search 554   
　　ㄴ20.3 Depth-ûrst search 563   
　　ㄴ20.4 Topological sort 573   
　　ㄴ20.5 Strongly connected components 576   
　ㄴ21 Minimum Spanning Trees 585   
　　ㄴ21.1 Growing a minimum spanning tree 586   
　　ㄴ21.2 The algorithms of Kruskal and Prim 591   
　ㄴ22 Single-Source Shortest Paths 604   
　　ㄴ22.1 The Bellman-Ford algorithm 612   
　　ㄴ22.2 Single-source shortest paths in directed acyclic graphs 616   
　　ㄴ22.3 Dijkstra’s algorithm 620   
　　ㄴ22.4 Difference constraints and shortest paths 626   
　　ㄴ22.5 Proofs of shortest-paths properties 633   
　ㄴ23 All-Pairs Shortest Paths 646   
　　ㄴ23.1 Shortest paths and matrix multiplication 648   
　　ㄴ23.2 The Floyd-Warshall algorithm 655   
　　ㄴ23.3 Johnson’s algorithm for sparse graphs 662   
　ㄴ24 Maximum Flow 670   
　　ㄴ24.1 Flow networks 671   
　　ㄴ24.2 The Ford-Fulkerson method 676   
　　ㄴ24.3 Maximum bipartite matching 693   
　ㄴ25 Matchings in Bipartite Graphs 704   
　　ㄴ25.1 Maximum bipartite matching (revisited) 705   
　　ㄴ25.2 The stable-marriage problem 716   
　　ㄴ25.3 The Hungarian algorithm for the assignment problem 723   
ㄴVII Selected Topics   
　ㄴIntroduction 745   
　ㄴ26 Parallel Algorithms 748   
　　ㄴ26.1 The basics of fork-join parallelism 750   
　　ㄴ26.2 Parallel matrix multiplication 770   
　　ㄴ26.3 Parallel merge sort 775   
　ㄴ27 Online Algorithms 791   
　　ㄴ27.1 Waiting for an elevator 792   
　　ㄴ27.2 Maintaining a search list 795   
　　ㄴ27.3 Online caching 802   
　ㄴ28 Matrix Operations 819   
　　ㄴ28.1 Solving systems of linear equations 819   
　　ㄴ28.2 Inverting matrices 833   
　　ㄴ28.3 Symmetric positive-deûnite matrices and least-squares   approximation 838   
　ㄴ29 Linear Programming 850   
　　ㄴ29.1 Linear programming formulations and algorithms 853   
　　ㄴ29.2 Formulating problems as linear programs 860   
　　ㄴ29.3 Duality 866   
　ㄴ30 Polynomials and the FFT 877   
　　ㄴ30.1 Representing polynomials 879   
　　ㄴ30.2 The DFT and FFT 885   
　　ㄴ30.3 FFT circuits 894   
　ㄴ31 Number-Theoretic Algorithms 903   
　　ㄴ31.1 Elementary number-theoretic notions 904   
　　ㄴ31.2 Greatest common divisor 911   
　　ㄴ31.3 Modular arithmetic 916   
　　ㄴ31.4 Solving modular linear equations 924   
　　ㄴ31.5 The Chinese remainder theorem 928   
　　ㄴ31.6 Powers of an element 932   
　　ㄴ31.7 The RSA public-key cryptosystem 936 ?   
　　ㄴ31.8 Primality testing 942   
　ㄴ32 String Matching 957   
　　ㄴ32.1 The naive string-matching algorithm 960   
　　ㄴ32.2 The Rabin-Karp algorithm 962   
　　ㄴ32.3 String matching with ûnite automata 967 ?   
　　ㄴ32.4 The Knuth-Morris-Pratt algorithm 975   
　　ㄴ32.5 Sufûx arrays 985   
　ㄴ33 Machine-Learning Algorithms 1003   
　　ㄴ33.1 Clustering 1005   
　　ㄴ33.2 Multiplicative-weights algorithms 1015   
　　ㄴ33.3 Gradient descent 1022   
　ㄴ34 NP-Completeness 1042   
　　ㄴ34.1 Polynomial time 1048   
　　ㄴ34.2 Polynomial-time veriûcation 1056   
　　ㄴ34.3 NP-completeness and reducibility 1061   
　　ㄴ34.4 NP-completeness proofs 1072   
　　ㄴ34.5 NP-complete problems 1080   
　ㄴ35 Approximation Algorithms 1104   
　　ㄴ35.1 The vertex-cover problem 1106   
　　ㄴ35.2 The traveling-salesperson problem 1109   
　　ㄴ35.3 The set-covering problem 1115   
　　ㄴ35.4 Randomization and linear programming 1119   
　　ㄴ35.5 The subset-sum problem 1124   
ㄴVIII Appendix: Mathematical Background  
　ㄴIntroduction 1139  
　ㄴA Summations 1140  
　　ㄴA.1 Summation formulas and properties 1140  
　　ㄴA.2 Bounding summations 1145  
　ㄴB Sets, Etc. 1153  
　　ㄴB.1 Sets 1153  
　　ㄴB.2 Relations 1158  
　　ㄴB.3 Functions 1161  
　　ㄴB.4 Graphs 1164  
　　ㄴB.5 Trees 1169  
　ㄴC Counting and Probability 1178  
　　ㄴC.1 Counting 1178  
　　ㄴC.2 Probability 1184  
　　ㄴC.3 Discrete random variables 1191  
　　ㄴC.4 The geometric and binomial distributions 1196  
　　ㄴC.5 The tails of the binomial distribution 1203  
　ㄴD Matrices 1214  
　　ㄴD.1 Matrices and matrix operations 1214  
　　ㄴD.2 Basic matrix properties 1219  
　ㄴBibliography 1227  
　ㄴIndex 1251  
  